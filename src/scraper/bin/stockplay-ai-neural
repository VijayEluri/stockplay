#!/usr/bin/env perl

################################################################################
# Configuration
#

# XXX: library location
use lib '../lib';

# Packages
use Date::Manip;
use DateTime::Format::DateManip;
use StockPlay::Factory;
use StockPlay::Exchange;
use StockPlay::Index;
use StockPlay::Security;
use AI::FANN qw(:all);
use List::Util qw(max min);

# Write nicely
use warnings;
use strict;

# Constants
my $DATA_START = DateTime::Format::DateManip->parse_datetime(ParseDate("2 year ago"));
my $DATA_END = DateTime::Format::DateManip->parse_datetime(ParseDate("1 month ago"));
my $CASCADE = 1;


################################################################################
# Main
#

# Load the factory
print "* Setting up factory\n";
my $factory = new StockPlay::Factory();

# Get the security
print "* Getting objects\n";
my $exchange = (grep { $_->symbol eq "BSE" } $factory->getExchanges())[0] or die();
my $security = (grep { $_->isin eq "BE0003755692" } $factory->getSecurities($exchange))[0] or die();
my $index = (grep { $_->isin eq "BE0389555039" } $factory->getIndexes($exchange))[0] or die();

# Fetch prognosis
print "* Fetching prognosis for " . $security->name . "\n";
my $ann = train($exchange, $index, $security);

exit(0);


################################################################################
# Routines
#

sub train {
	my ($exchange, $index, $security) = @_;
	
	#
	# Setup
	#

	# Create a new network with 1 layer, 5 inputs, and 1 output.
	# INPUTS:
	# - Closing price
	# - Closing price of the main index
	# - Volume
	# - High price
	# - Low price
	# - Day is monday
	# - Day is tuesday
	# - Day is wednesday
	# - Day is thursday
	# - Day is friday
	# OUTPUTS:
	# - Closing price of of next day
	print "- Creating neural network\n";
	my $ann;
	if ($CASCADE) {
		$ann = AI::FANN->new_shortcut(10, 1);
		$ann->training_algorithm(FANN_TRAIN_RPROP);
		$ann->hidden_activation_function(FANN_SIGMOID_SYMMETRIC);
		$ann->output_activation_function(FANN_LINEAR_PIECE);
		$ann->train_error_function(FANN_ERRORFUNC_LINEAR);
	} else {
		$ann = AI::FANN->new_standard(10, 5, 1);
		$ann->hidden_activation_function(FANN_LINEAR);
		$ann->output_activation_function(FANN_LINEAR);
	}
	$ann->print_parameters();


	#
	# Data
	#

	# Load the quotes
	print "- Fetching data for security\n";
	my @quotes = $factory->getQuotes($DATA_START, $DATA_END, $security);
	@quotes = quote_truncate( @quotes );

	# Load the index quotes
	print "- Fetching data for index\n";
	my @quotes_index = $factory->getQuotes($DATA_START, $DATA_END, $index);
	@quotes_index = quote_truncate( @quotes_index );
	die() unless @quotes_index;

	# Build a set of training data
	print "- Building training data\n";
	my $index_closing = 0;
	my (@input, @output);
	for (my $i = 0; $i < @quotes-2; $i++) {
		my $quote = $quotes[$i];
		
		# Look for index closing price
		my $index_quote = (grep { DateTime->compare($_->time, $quotes[$i+1]->time) == 0} @quotes_index)[0];
		if (defined $index_quote) {
			$index_closing = $index_quote->open;
		} else {
			print "! Warning: could not find index quote for " . $quote->time->year . "-" . $quote->time->month . "-". $quote->time->day . "\n";
		}
		
		# Generate inputs
		my $i_closing = $quotes[$i+1]->open;
		my $i_closing_index = $index_closing;
		my $i_volume = $quote->volume;
		my $i_high = $quote->high;
		my $i_low = $quote->low;
		my $i_monday = $quote->time->dow == 1 ? 1 : 0;
		my $i_tuesday = $quote->time->dow == 2 ? 1 : 0;
		my $i_wednesday = $quote->time->dow == 3 ? 1 : 0;
		my $i_thursday = $quote->time->dow == 4 ? 1 : 0;
		my $i_friday = $quote->time->dow == 5 ? 1 : 0;
		push(@input, [$i_closing, $i_closing_index, $i_volume, $i_high, $i_low, $i_monday, $i_tuesday, $i_wednesday, $i_thursday, $i_friday]);
		
		# Generate outputs
		my $o_closing = $quotes[$i+2]->open;
		push(@output, [$o_closing]);
	}

	# Scale input data
	my ($i_closing_min, $i_closing_max) = scale(\@input, 0);
	my ($i_closing_index_min, $i_closing_index_max) = scale(\@input, 1);
	my ($i_volume_min, $i_volume_max) = scale(\@input, 2);
	my ($i_high_min, $i_high_max) = scale(\@input, 3);
	my ($i_low_min, $i_low_max) = scale(\@input, 4);

	# Scale output data
	my ($o_closing_min, $o_closing_max) = scale(\@output, 0);

	# Merge input and output data
	my @data;
	for (my $i = 0; $i < @input; $i++) {
		push(@data, $input[$i], $output[$i]);
	}

	#
	# Learn
	#

	print "- Training network on " . (scalar @data)/2 . " samples\n";
	my $train = AI::FANN::TrainData->new(@data);
	if ($CASCADE) {
		$ann->cascadetrain_on_data(
			$train,
			40,	# Amount of neurons
			1,	# Neurons between information prints
			0.0001	# Desired rate of error
		);
	} else {
		$ann->train_on_data(
			$train,
			50000,	# Amount of epochs
			1000,	# Epochs between information prints
			0.001	# Desired rate of error
		);
	}
	$ann->print_connections();
	
	print "- MSE after learning: " . $ann->MSE . "\n";
}

sub scale {
	my ($arrayref, $index) = @_;
	
	my $max = max map { $_->[$index] } @$arrayref;
	my $min = min map  { $_->[$index] } @$arrayref;
	for (my $i = 0; $i < @$arrayref; $i++) {
		$arrayref->[$i]->[$index] = ($arrayref->[$i]->[$index] - $min) / ($max - $min);
	}
	
	return ($min, $max);
}

sub descale {
	my ($arrayref, $index, $min, $max) = @_;
	
	for (my $i = 0; $i < @$arrayref; $i++) {
		$arrayref->[$i]->[$index] = ($max - $min) * $arrayref->[$i]->[$index] + $min;
	}
}

sub descale_value {
	my ($value, $min, $max) = @_;
	
	return ($max - $min) * $value + $min;
}

sub quote_truncate {
	my (@quotes) = @_;
	@quotes = sort { DateTime->compare($a->time, $b->time) } @quotes;
	my @quotes_truncated;
	my $quote_previous;
	foreach my $quote (@quotes) {
		# New quote
		if (not defined $quote_previous) {
			$quote_previous = $quote;
		}
		
		# Quote at same day
		elsif ($quote->time->year == $quote_previous->time->year
				&& $quote->time->month == $quote_previous->time->month
				&& $quote->time->day == $quote_previous->time->day) {
			# Prefer most recent quote
			if (DateTime->compare($quote_previous->time, $quote->time) == -1) {
				$quote_previous = $quote;
			}
		}
		
		# Other day
		else {
			push @quotes_truncated, $quote_previous;
			$quote_previous = $quote;
		}
	}
	return @quotes_truncated;
}

__END__

################################################################################
# Documentation
#

=pod

=head1 NAME

stockplay-ai-neural - Neural-network based AI component

=head1 SYNOPSIS

=head1 COPYRIGHT

Copyright 2010 The StockPlay development team as listed in the AUTHORS file.

This software is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public Licence (GPL) as published by the
Free Software Foundation (FSF).

The full text of the license can be found in the
LICENSE file included with this module.

=cut
