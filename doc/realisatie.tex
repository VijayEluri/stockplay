\chapter{Dataontwerp}

\begin{figure}[h!]
	\centering
		\includegraphics[width=0.5\textwidth]{images/realisatie/ER_Diagram}
	\caption{Entity-relationship model.}
\end{figure}

\section{Ontwerp backend}
\todo{dit hoort hier niet}
De klassen die de persistente data uit de database moeten weergeven staan opgesomd in onderstaand klassendiagram:

\begin{figure}[h!]
	\centering
		\includegraphics[width=0.5\textwidth]{images/realisatie/Class_Diagram}
	\caption{Klassendiagram persistente data in backend.}
\end{figure}


\chapter{Procedureontwerp}

\section{Backend protocol}

Zoals vermeld in de behoeftenanalyse wordt alle databasetoegang uitgevoerd via een gemeenschappelijke backend. De interface hiervoor stelt echter een aantal bijzondere eisen:
\begin{itemize}
\item{Taalonafhankelijk: aangezien de interfaces met behulp van verschillende programmeertalen gerealiseerd worden, moet de interface toegankelijk zijn vanuit een zo wijd mogelijke waaier aan programmeertalen.}
\item{Lichtgewicht: als een mobiele interface een mogelijke uitbreiding kan zijn, moet het gekozen protocol compact zijn en mogen de eventueel benodigde libraries niet te zwaar zijn.}
\item{Toegankelijk: omdat interfaces niet noodzakelijk uitgevoerd worden op hetzelfde systeem van de backend, is het mooi meegenomen als het protocol geen probleem vormt in gelimiteerde omgevingen.}
\end{itemize}

Na verschillende kandidaten overwogen te hebben, hebben we gekozen voor XML-RPC. Dit is een lichtgewicht Remote Procedure protocol, dewelke methodeaanvragen en -antwoorden verpakt in XML-data en ze als POST request verstuurd over het HTTP protocol (zie bijlage \ref{chap:xml-rpc} voor de exacte specificatie).

Het protocol voldoet aan de opgestelde eisen: aangezien het verderbouwt op het bestaande HTTP-protocol kan het gebruik maken van diens mogelijkheden (zoals compressie en encryptie), en kan het indien een specifieke bibliotheek onbestaande is eenvoudig verwerkt worden via reeds bestaande HTTP- en XML-bibliotheken. Bovendien verschilt de communicatie niet van regulier browsen waardoor de toegankelijkheid in gelimiteerde omgevingen ook toeneemt.

Voor de programmeertalen die we gaan gebruiken bij het implementeren blijken er reeds verschillende bibliotheken beschikbaar te zijn, wat het gemak van gebruik opnieuw verhoogt. Hierbij een opsomming van de specifieke bibliotheken die we zullen gebruiken om informatie te versturen en ontvangen over het XML-RPC protocol:
\begin{itemize}
\item{\textbf{Perl}: \makeurl{XML::RPC}{http://search.cpan.org/~daan/XML-RPC-0.9/lib/XML/RPC.pm}}
\item{\textbf{C\#}: \makeurl{XML-RPC.NET}{http://www.xml-rpc.net/}}
\item{\textbf{Java}: \makeurl{Apache XML-RPC}{http://ws.apache.org/xmlrpc/}}
\end{itemize}

Aangezien XML-RPC geen ondersteuning biedt voor namespaces of andere vormen van functieorganisatie, hanteren we zelf een mechanisme om dit te bekomen: een methode-naam bestaat altijd uit twee delen, gescheiden door een punt. Het deel voor het scheidingsteken duidt het pakket aan, het deel erna de specifieke methode.
Zo delen we de backend op in volgende primaire klassen:
\begin{itemize}
\item{System: functionaliteit voor beheer van het systeem.}
\item{User: beheer van gebruikers, ook voor gebruikers zelf.}
\item{Finance: functionaliteit gerelateerd met het beurswezen.}
\end{itemize}
Hogere-orde klassen zijn eventueel ook mogelijk (zoals \emph{System.Database}), maar niet verplicht. De semantiek is daarbij identiek aan primaire klassen, met een punt als scheidingsteken.

\subsection{Algemene foutcodes}

De XML-RPC specificatie biedt ondersteuning voor foutberichten, in de form van een bericht met een $<$fault$>$ tag. Die tag moet steeds twee $<$member$>$ tags bevatten, namelijk een foutcode $<$faultCode$>$ van het integer type, en een foutbericht $<$faultString$>$ van het string type. Elk van de klassen kan zo specifieke foutmeldingen vastleggen.
Maar er zijn ook generieke foutmeldingen, die van toepassing zijn op alle klassen. Deze foutmeldingen, waarvan de foutcode in het bereik $[0, 100[$ valt, worden hieronder beschreven:

\begin{table}
\begin{tabular}{| c p{5cm} p{7cm} |}
	\hline
	Foutcode & Foutbericht & Controle \\
	\hline
	
	0 & Version Not Supported & De client gebruikt een verkeerd communicatieprotocol. \\
	\hline
	
	$[1-10[$ & \emph{Subsystem failures.} & \\
	1 & Internal Failure & Verifieer de status van de backend, de log kan hierbij helpen. \\
	2 & Database Failure & Er is een probleem met de database (onbeschikbaar, corrupt, ...), zie de log voor meer details. \\
	\hline
	
	$[10-20[$ & \emph{Service issues.} & \\
	10 & Service Unavailable & De backend kan tijdelijk niet gebruikt worden (werkzaamheden, overloaded, ...). \\
	11 & Unauthorized & Meld u aan vooraleer deze functie te gebruiken. \\
	\hline
	
	$[20-30[$ & \emph{Method issues.} & \\
	20 & Not Found & Methode niet gevonden, verifieer de schrijfwijze en de klasse. \\
	21 & Bad Request & Probleem met de parameters, controleer het gebruik van de methode. \\
	\hline
\end{tabular}
\caption{Generieke foutcodes in het backend-protocol.}
\end{table}

\subsection{Authenticatie en autorisatie}

Aangezien het XML-RPC protocol gebruik maakt van het HTTP-protocol, kunnen we diens functionaliteit gebruiken om authenticatie te bekomen. Daartoe zullen we gebruik maken van \emph{basic authentication}, waarbij de client indien gevraagt een gebruikersnaam en wachtwoord naar de server doorstuurd.
\todo{Dit is tijdelijk}

Afhankelijk van de capabiliteiten van het XML-RPC pakket dat we in de backend gebruiken (Apache XML-RPC), kan dit op twee manieren verlopen. Indien de bibliotheek ondersteuning biedt voor het on-demand inschakelen van authenticatie gebaseerd op de ontvangen request, kunnen we zo wanneer benodigd \emph{basic authentication} inschakelen en de webserver zelf een HTTP-401 laten terugsturen, zonder hiervoor extra code in de backend benodigd is.
Als deze optie niet dynamisch ingeschakeld kan worden, zullen we zelf een eigen foutmelding moeten terugsturen die aanduidt dat authorisatie benodigd is. Als de client zo een $<$fault$>$-bericht ontvangt, zal die een nieuwe XML-RPC socket openen op een alternatieve URL (bijvoorbeeld \texttt{http://server.hogent.be/authenticated}). Aangezien de URL nu verschillend is, kunnen we de webserver in de backend zodanig configureren dat authenticatie vereist is voor die zone. Zo bekomen we eveneens verplichte authenticatie voor bepaalde methodes, maar dit door ze enkel beschikbaar te stellen in een subset van het serverdomein. Dit vereist enige extra code in de backend.

Autorisatie tenslotte is beperkt: in de huidige opzet ondersteunen we geen flexibel-toegekende rechten, enkel een bit die bepaalt of de gebruiker een administrator is of niet.

\todo{gebruikers-autorisatie ook via dit systeem, return rechten bitmap / ID}

\subsection{System-klasse}

Deze klasse biedt de client mogelijkheden om het systeem te beheren, met name ophalen van informatie, wijzigen van configuraties, en (her)starten of stoppen van bepaalde subsystemen.


\begin{itemize}
\item{\textbf{Gebruik}: }
\item{\textbf{Parameters}:}
	\begin{itemize}
	\item{}
	\end{itemize}
\item{\textbf{Output}:}
	\begin{itemize}
	\item{}
	\end{itemize}
\item{\textbf{Autorisatie}: }
\end{itemize}

\paragraph{Backend.Status}
\begin{itemize}
\item{\textbf{Gebruik}: status van de backend ophalen.}
\item{\textbf{Parameters}: geen.}
\item{\textbf{Output}: integer die status beschrijft:}
	\begin{itemize}
	\item{0: maintenance-mode}
	\item{1: de backend werkt}
	\end{itemize}
\item{\textbf{Autorisatie}: administrator-rechten benodigd}
\end{itemize}

\paragraph{Backend.Stats}
\begin{itemize}
\item{\textbf{Gebruik}: backend-statistieken ophalen.}
\item{\textbf{Parameters}: geen.}
\item{\textbf{Output}: struct met statistieken}
	\begin{itemize}
	\item{users: aantal gebruikers online}
	\item{req: aantal verwerkte XML-RPC requests}
	\item{uptime: hoe lang de backend al draait}
	\end{itemize}
\item{\textbf{Autorisatie}: administrator-rechten benodigd.}
\end{itemize}

\paragraph{Backend.Restart}
\begin{itemize}
\item{\textbf{Gebruik}: de backend herstarten.}
\item{\textbf{Parameters}: geen.}
\item{\textbf{Output}: bool die indiceert of de actie succesvol was.}
\item{\textbf{Autorisatie}: administrator-rechten benodigd.}
\end{itemize}

\paragraph{Backend.Stop}
\begin{itemize}
\item{\textbf{Gebruik}: de backend permanent stilleggen.}
\item{\textbf{Parameters}: geen.}
\item{\textbf{Output}: bool die indiceert of de actie succesvol was.}
\item{\textbf{Autorisatie}: administrator-rechten benodigd.}
\end{itemize}

\paragraph{Database.Status}
\begin{itemize}
\item{\textbf{Gebruik}: status van de database ophalen.}
\item{\textbf{Parameters}: geen.}
\item{\textbf{Output}: integer die status beschrijft:}
	\begin{itemize}
	\item{0: database niet te bereiken}
	\item{1: de backend werkt}
	\end{itemize}
\item{\textbf{Autorisatie}: administrator-rechten benodigd}
\end{itemize}

\paragraph{Database.Stats}
\begin{itemize}
\item{\textbf{Gebruik}: database-statistieken ophalen. Dit zijn de statistieken geleverd door de database zelf, ze zijn dus niet beperkt tot acties ondernomen door de backend.}
\item{\textbf{Parameters}: geen.}
\item{\textbf{Output}: struct met statistieken}
	\begin{itemize}
	\item{queries: aantal uitgevoerde queries}
	\item{uptime: hoe lang de database al draait}
	\item{traffic: hoeveelheid data verzonden en ontvangen}
	\item{slow\_queries: aantal queries die teveel uitvoeringstijd vergden}
	\end{itemize}
\item{\textbf{Autorisatie}: administrator-rechten benodigd.}
\end{itemize}

\paragraph{Scraper.Status}
\begin{itemize}
\item{\textbf{Gebruik}: status van de scraper ophalen.}
\item{\textbf{Parameters}: geen.}
\item{\textbf{Output}: integer die status beschrijft:}
	\begin{itemize}
	\item{0: niet geactiveerd}
	\item{1: inactief}
	\item{2: bezig met data-mining}
	\end{itemize}
\item{\textbf{Autorisatie}: administrator-rechten benodigd}
\end{itemize}

\paragraph{Scraper.Stats}
\begin{itemize}
\item{\textbf{Gebruik}: scraper-statistieken ophalen.}
\item{\textbf{Parameters}: geen.}
\item{\textbf{Output}: struct met statistieken}
	\begin{itemize}
	\item{executes: aantal voltooide plugin-uitvoeringen}
	\item{uptime: hoe lang de scraper al draait}
	\item{traffic: hoeveelheid data verzonden en ontvangen}
	\item{plugins: aantal geactiveerde plugins}
	\item{securities: aantal beschikbare effecten}
	\item{exchanges: aantal beschikbare beurzen}
	\item{indexes: aantal beschikbare indexen}
	\item{delay: tijd tot de volgende plugin-uitvoering}
	\item{memory: geheugengebruik}
	\end{itemize}
\item{\textbf{Autorisatie}: administrator-rechten benodigd.}
\end{itemize}

\paragraph{Scraper.Restart}
\begin{itemize}
\item{\textbf{Gebruik}: de scraper herstarten.}
\item{\textbf{Parameters}: geen.}
\item{\textbf{Output}: bool die indiceert of de actie succesvol was.}
\item{\textbf{Autorisatie}: administrator-rechten benodigd.}
\end{itemize}

\paragraph{Scraper.Stop}
\begin{itemize}
\item{\textbf{Gebruik}: de scraper permanent stilleggen.}
\item{\textbf{Parameters}: geen.}
\item{\textbf{Output}: bool die indiceert of de actie succesvol was.}
\item{\textbf{Autorisatie}: administrator-rechten benodigd.}
\end{itemize}


\subsection{User-klasse}

Hier vindt men de nodige methodes terug om gebruikers te beheren. Dit is echter niet beperkt tot de administrator: ook gebruikers zelf kunnen hun eigen profiel (in beperktere mate) beheren.

\paragraph{List}

\begin{itemize}
\item{\textbf{Gebruik}: lijst met publieke informatie opvragen van de gebruikers}
\item{\textbf{Parameters}: een filter}
\item{\textbf{Output}: een lijst met structs}
	\begin{itemize}
	\item{id}
	\item{nickname}
	\item{regdate}
	\item{points}
	\end{itemize}
\item{\textbf{Autorisatie}: geen benodigd}
\end{itemize}

\paragraph{Details}

\begin{itemize}
\item{\textbf{Gebruik}: lijst met publieke informatie opvragen van de gebruikers}
\item{\textbf{Parameters}: een lijst met id's}
\item{\textbf{Output}: een lijst met structs}
	\begin{itemize}
	\item{id}
	\item{firstName}
	\item{lastName}
	\item{rrn}
	\item{cash}
	\item{startkapitaal}
	\end{itemize}
\item{\textbf{Autorisatie}: Gebruiker zelf of een gebruiker met administratorrechten}
\end{itemize}

\paragraph{Create}

\begin{itemize}
\item{\textbf{Gebruik}: aanmaken van een nieuwe gebruiker}
\item{\textbf{Parameters}: struct met de gebruikers}
	\begin{itemize}
	\item{}
	\end{itemize}
\item{\textbf{Output}: id van de aangemaakte gebruiker}
\todo{specifieke foutcode genereren} 
\item{\textbf{Autorisatie}: een gebruiker met adminstrator}
\end{itemize}

\paragraph{Modify}

\paragraph{Remove}

\paragraph{Portefolio.List}

\paragraph{Portefolio.History}

1e param is struct die range definiëert, response is array van structs (datetime, points).

\paragraph{Orders.List}

\paragraph{Orders.Create}

\paragraph{Orders.Cancel}

\paragraph{Transactions.List}


\subsection{Finance-klasse}

Tenslotte zijn er nog de methodes gerelateerd met het effectieve beurswezen, die (hoofdzakelijk) terug te vinden zijn in deze klasse. Enkel het ophalen van de portefolio bevindt zich, logischerwijs, in de User-klasse.

\paragraph{Exchange.List}

\paragraph{Exchange.Modify}

\paragraph{Index.List}

\paragraph{Index.Modify}

\paragraph{Security.List}

ook flag key
output is enkel opprevlakkige informatie om tabel te maken

\paragraph{Security.Details}

input is ID uit Security.List

\paragraph{Security.Modify}

plus "hide" flag etc

\paragraph{Security.Flag}

1e param type vlag
2e param bool voor set/unset
3e param array array van security ID's


